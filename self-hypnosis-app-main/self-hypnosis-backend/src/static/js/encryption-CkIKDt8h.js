var c=(y,e,t)=>new Promise((r,a)=>{var s=i=>{try{n(t.next(i))}catch(h){a(h)}},o=i=>{try{n(t.throw(i))}catch(h){a(h)}},n=i=>i.done?r(i.value):Promise.resolve(i.value).then(s,o);n((t=t.apply(y,e)).next())});class l{constructor(){this.algorithm="AES-GCM",this.keyLength=256,this.ivLength=12}stringToArrayBuffer(e){return new TextEncoder().encode(e)}arrayBufferToString(e){return new TextDecoder().decode(e)}arrayBufferToBase64(e){const t=new Uint8Array(e);let r="";for(let a=0;a<t.byteLength;a++)r+=String.fromCharCode(t[a]);return btoa(r)}base64ToArrayBuffer(e){const t=atob(e),r=new Uint8Array(t.length);for(let a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return r.buffer}deriveKey(e,t=null){return c(this,null,function*(){try{const r=t?this.base64ToArrayBuffer(t):crypto.getRandomValues(new Uint8Array(16)),a=yield crypto.subtle.importKey("raw",this.stringToArrayBuffer(e),{name:"PBKDF2"},!1,["deriveKey"]);return{key:yield crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},a,{name:this.algorithm,length:this.keyLength},!1,["encrypt","decrypt"]),salt:this.arrayBufferToBase64(r)}}catch(r){throw console.error("Key derivation failed:",r),r}})}encrypt(e,t){return c(this,null,function*(){try{const{key:r,salt:a}=yield this.deriveKey(t),s=crypto.getRandomValues(new Uint8Array(this.ivLength)),o=yield crypto.subtle.encrypt({name:this.algorithm,iv:s},r,this.stringToArrayBuffer(e)),n={salt:a,iv:this.arrayBufferToBase64(s),data:this.arrayBufferToBase64(o)};return btoa(JSON.stringify(n))}catch(r){throw console.error("Encryption failed:",r),r}})}decrypt(e,t){return c(this,null,function*(){try{const r=JSON.parse(atob(e)),{salt:a,iv:s,data:o}=r,{key:n}=yield this.deriveKey(t,a),i=yield crypto.subtle.decrypt({name:this.algorithm,iv:this.base64ToArrayBuffer(s)},n,this.base64ToArrayBuffer(o));return this.arrayBufferToString(i)}catch(r){throw console.error("Decryption failed:",r),r}})}simpleEncrypt(e,t){return c(this,null,function*(){try{const r="selfhypnosis-salt-16bytes",a=yield crypto.subtle.importKey("raw",this.stringToArrayBuffer(t.padEnd(32,"0").substring(0,32)),{name:this.algorithm},!1,["encrypt"]),s=crypto.getRandomValues(new Uint8Array(this.ivLength)),o=yield crypto.subtle.encrypt({name:this.algorithm,iv:s},a,this.stringToArrayBuffer(e)),n=new Uint8Array(s.length+o.byteLength);return n.set(s),n.set(new Uint8Array(o),s.length),this.arrayBufferToBase64(n.buffer)}catch(r){return console.error("Simple encryption failed:",r),e}})}simpleDecrypt(e,t){return c(this,null,function*(){try{const r=this.base64ToArrayBuffer(e),a=r.slice(0,this.ivLength),s=r.slice(this.ivLength),o=yield crypto.subtle.importKey("raw",this.stringToArrayBuffer(t.padEnd(32,"0").substring(0,32)),{name:this.algorithm},!1,["decrypt"]),n=yield crypto.subtle.decrypt({name:this.algorithm,iv:a},o,s);return this.arrayBufferToString(n)}catch(r){return console.error("Simple decryption failed:",r),e}})}generateSecureKey(e=32){const t=new Uint8Array(e);return crypto.getRandomValues(t),this.arrayBufferToBase64(t.buffer)}hash(e){return c(this,null,function*(){try{const t=this.stringToArrayBuffer(e),r=yield crypto.subtle.digest("SHA-256",t);return this.arrayBufferToBase64(r)}catch(t){throw console.error("Hashing failed:",t),t}})}verifyHash(e,t){return c(this,null,function*(){try{return(yield this.hash(e))===t}catch(r){return console.error("Hash verification failed:",r),!1}})}}const f=new l,d=(y,e)=>f.simpleEncrypt(y,e),p=(y,e)=>f.simpleDecrypt(y,e);export{p as decrypt,f as default,d as encrypt};
